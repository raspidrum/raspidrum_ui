# Принципы взаимодействия при изменении регулировок

При изменении регулировок (уровень, панорамирование, параметры Fx и пр.) отправляется сетевой запрос. Изменение регулировки выполняется плавно и может генерировать слишком много событий, создавая высокую сетевую нагрузку. Изменение даже может происходить быстрее, чем будет успевать обрабатываться.

## Сокращение кол-во событий при измнении

**Вариант 1. Дискретная регулировка**
Например, кол-во ступеней изменений от мин до макс ранво 100
Недостаток: изменение от мин до макс сгенерирует 100 событий. Но само изменение может быть быстрым, поэтому достаточно, например, 10 событий

DONE: разобраться, как часто генерит события слайдер. Например, добавить в счетчик и инкрементом. - Часто

**Вариант 2. Задержки**
В течение времени таймаута накапливать события. По истечению таймаута отправлять последнее


Вариант 1 использовать в виджетах (например, в слайдере)
Вариант 2 использовать репозитории

## Реализация задержек при отправке событий

Создается очередь. ViewModel вызывает в репозитории метод, к-й добавляет событие в очередь.
Если нет выполняющихся запросов, то вычитывание из очереди выполняется сразу. Иначе по истечению таймаута.
По истечению таймаута вычитываются все события из очереди. В обработку берется самое последнее, а остальные игнорируются.

Если таймаут вышел, а ответ от предыдущего запроса еще не получен, то все равно вычитываются события из очереди и отправляется запрос на бэк. Это гарантирует стабильную работу, если предыдущий запрос или его ответ не обработается по любой причине.


### Гарантированная последовательность обработки событий
Для каждого события генерируется номер из последовательно нарастающей последовательности.
Последовательность инициализируется при первом событии изменении регулировки.
Последовательность должна иметь размерность не менее 32бит, но и больше 64 нет смысла.
Номер из последовательности отправляется на бэк и он же передается обратно в ответе.
В репозитории фиксируется последний успешно обработанный номер. Если номер в ответе меньше номера в репозитории, то ответ игнорируется. Иначе в репозитории фиксируется как успешно обработанный.
Теоретически, может потеряться самое последнее событие. Т.о можем получить расхождение в визуальном положении регулировки и фактически установленном значении. Вариант решения: по истечению таймаута получения ответа по последнему событию (требуется отдельно фиксировать успешно обработанные события и последний отправленный запрос) последний запрос считается ошибочным и даже если будет получен ответ - будет проигнорирован. Репозиторий вызывает колбэк во viewModel для установки в регуляторе фактически обработанного значения. Необходимо учесть, что к получению ответа экран уже может быть зарыт. Но для дальнейшего сохранения пресета значения должно быть сохранено все-равно. Т.к вероятность такой потери не велика, то данную оптимизацию можно отложить.


Для каждой регулировки создается независимая очередь и последовательность.
Т.к. в любой момент времени будет изменяться одна регулировка (максимум несколько, если очень быстро или несколькими пальцами менять несколько регулировок), то большую часть времени они будут пустые.


После добавления нового значения в очередь проверяется наличие запущенного таймера. Если нет таймера, то запускается на минимальное время (например, 1 мс). Иначе завершаем добавление в очередь и выходим.
При срабатывании таймера вычитываются все события из очереди. Последнее отправляется в запросе на бэк. И ставится таймер на ожидание ответа.
Эти таймеры равнозначны. Т.е. если до истечения времени таймера будет добавлено новое значение в очередь, то новый таймер на его обработку не будет поставлен. При истечении таймера, также вычитывается последнее событие из очереди, отправляется запрос на бэк и перезапускается таймер.
При получении ответа от бэка таймер прерывается. Также вычитывается последнее сообщение из очереди, отправляется запрос на бэк и запускается таймер.
Может возникнуть конфликт: 
  Кейс1. таймер истек, ответ не был получен. Был отправлен новый запрос на бэк, таймер перезапущен. Получен ответ от первого запроса.
    Например, ответ мог быть получен почти сразу после запуска таймера. Если еще отправить один запрос и перезапустить таймер, то скорее всего ответы прийдут примерно в одно время. И так будет продолжаться дальше. Т.о. получим двойную нагрузку на бэк.
    Альтернативный вариант: таймер перезапускать только после его завершения и отправки новых запросов на бэк.

  Кейс2. таймер истек, ответ не получен. Новый запрос не поступил, таймер не запущен. Получен ответ от первого запроса.


Итоговая обработка ответа:
      - если seq в ответе больше последнего обработанного, то обновляем его
        - иначе игнорируем ответ

Итоговая обработка по истечению таймера
      - вычитываем события из очереди
      - если есть хоть одно, то 
        - отправляем асинхронный запрос с последним событием
        - фиксируем seq активного запроса
        - запускаем таймер
      Дальнейшие действия необходимы только для отправки колбэка об успешной отработки всех запросов. Это опционально и на первом этапе не реализовывается.
      - если событий больше нет 
        - если нет активных запросов, то отправляем колбэк с последним значением, к-е было обработано на бэке
        - если есть, то запускаем контрольный таймер
          - при истечение этого таймера выполняются все действия выше за исключением:
            - контрольный таймер больше не запускается
            - колбэк отправляется без проверки активных запросоа
  
Возможные проблемы:
  - т.к. запросы на бэк отправляются с фиксированной частотой (значение таймера), то при ответе бека дольше чем время таймера запросы на бэк могут накапливаться.
    - возможное решение: при наличии какого-то кол-ва активных запросов, не отправлять новые запросы и перезапускать таймер с меньшим временем


